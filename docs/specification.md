# プロセッサの仕様

このページでは，本実験で設計するプロセッサが満たすべき仕様について説明します．

## アドレスマップ
* $～は16進の数字を表します．
* アドレスはバイト単位です．
* 各制御レジスタはそれぞれ16bit幅です．

|アドレス|説明|
|--|--|
| $0000-$1fff | ユーザーが使えるメモリ領域 |
| $2000-$3fff | ソートデータ（4096個） |
| $4000  | ソート終了レジスタ．ソート終了時にプログラムから1を書き込む．ここに書き込むと，サイクル数のカウントが止まる． |
| $4002  | ソート数レジスタ．ソート終了時にプログラムからソート数を書き込む．|
| $4004  | デバッグ用LED．プログラムから書き込んだ値に応じて，ボード上のLEDを光らせる |
| $4006  | 7-Seg LED 制御．ここに書き込んだ値に応じて，7-Seg LED に数字を表示．0 : サイクル数をLEDに表示   1 : IO_ADDR_LED0 から IO_ADDR_LED1 に書いた値を表示　|
| $4010 - $401e | 7-Seg LED の各桁の値を書き込む．16bit x 8 個で8桁分ある．|
| $4020: ソート開始  | プログラム開始時にこのレジスタを読み出し，最下位ビットが1になったら処理を開始する |
| $4022: CE スイッチ | ここを読むと，最下位 bit に CE スイッチの状態が取れる．0:スイッチを押したとき 1:スイッチが離されたとき |
| $4024: CP スイッチ | ここを読むと，最下位 bit に CP スイッチの状態が取れる．0:スイッチを押したとき 1:スイッチが離されたとき |
| $4026: CH スイッチ | ここを読むと，最下位 bit に CH スイッチの状態が取れる．0:スイッチを押したとき 1:スイッチが離されたとき |
| $4028: 現在のサイクル | ここを読むと現在のサイクル数が取れる |

## プログラム

以下の1～4の処理を実装してください

1. ソート開始レジスタ（$4020）を読み出し，最下位ビットが1になるまで待機

	例：
	```
		sub $1, $1, $1       // $1 をゼロクリア
	WAIT:
		lw   $2, 0x4020($1)　// $4020 の読みだし
		andi $2, $2, 1       // 論理積により，最下位ビットのみを取り出す
		beq  $2, $1, WAIT    // 0 だったら WAIT にもどる
	```

	注意：
	* ソート開始レジスタは1で開始なことに注意．CH とかのスイッチとは逆．
	* CH, CP, CE は，押してない状態で 1，押した状態で 0 になる．

2. ソート実行
   * $2000～$3fff にあるデータを昇順にソートしてください．
   * 処理が終わった後，この領域に昇順にデータが格納されていればよいです．
   * （昇順：小さい値から順）
   * $0000～$1fff のメモリは自由に使って良いです．

3. ソート終了
   * ソート数レジスタ（$4002）に，ソートしたデータの個数を書き込んでください
   * ソート終了レジスタ（$4000）に，1を書き込んでください
   * ソート終了レジスタへの書き込みの例：

		```
		sub $1, $1, $1      // $1 をゼロクリア
		sub $2, $2, $2      // $2 をゼロクリア
		addi $1, $1, 1      // $1 を 1 に
		sw   $1, 0x4000($2) // $1 を $4000 にストア
		```

4. ソート結果の表示
   * $4006, $4010-$401e を 使って，CP（$4024） が押されるたびにソート結果が表示されるようにしてください
   * 以下はC言語で書いた場合のこの処理のイメージ

		```
		short* ledCtrl = (short*)0x4006; // LED 制御レジスタ
		short* led     = (short*)0x4010; // LED 出力レジスタ
		short* cp      = (short*)0x4024; // CP スイッチ
		short* address = (short*)0x2000; // ソートデータの先頭アドレス
			
		
		while(1){
			
			while( ( *cp & 1 ) == 1 ){ // CP レジスタの最下位ビットが1の間は待つ
				continue;
			}
			
			*ledCtrl = 1; // $4006 に 1 を書いて LED をユーザー出力に切り替え
			
			int dataValue = *address; // ソート結果データの読み込み
			int addrValue = (int)address;　// アドレスを一時変数に格納
			
			// 値の表示
			for( int i = 0; i < 4; i ++ ){
				// 4bit（一桁）ずつ書き込む
				// 書き込む際，上の12ビット無視されるので，そのまま書き込んで良い
				// ここでは $4010, $4012, $4014, $4016 に書き込みが行われる
				*(led+i) = dataValue ;
				// 右に4ビットずらして，次の書き込みに備える
				dataValue = dataValue >> 4;
			}
		
			// アドレスの表示
			// やってることは上と同じ
			for( int i = 0; i < 4; i ++ ){
				*(led+i+4) = addrValue ;
				addrValue = addrValue >> 4; 
			}
			
			// 表示アドレスの更新
			address++;
		
			// CPボタンがはなされるのを待つ
			while( ( *cp & 1 ) == 0 ){ // CP レジスタの最下位ビットが0の間は待つ
				continue;
			}
		}
		```